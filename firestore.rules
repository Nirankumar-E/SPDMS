/**
 * @file firestore.rules
 * @description Security rules for a citizen services portal application.
 *
 * @philosophy
 * This ruleset enforces a strict user-ownership model. All user-related data,
 * including account information and login history, is private and can only be
 * accessed by the authenticated owner of that data. The security model defaults
 * to denying all access, granting permissions explicitly and granularly.
 *
 * @structure
 * Data is organized under a top-level `/users` collection. Each user's data
 * is stored in a document where the document ID matches the user's Firebase
 * Authentication UID (`/users/{userId}`). All related private data, such as
 * login attempts, is stored in subcollections under that user's document.
 * This structure leverages path-based security, which is highly performant
 * and easy to reason about.
 *
 * @decisions
 * - **Strictly Private Data**: There is no public or shared data in this model.
 *   All read and write operations require an authenticated user.
 * - **User Isolation**: Users are strictly isolated. They cannot read, list,
 *   or modify any data outside of their own document tree (`/users/{their_own_uid}`).
 * - **No User Listing**: Listing the top-level `/users` collection is explicitly
 *   disallowed to prevent leaking user information.
 * - **Relational Integrity**: While data shapes are flexible (Prototyping Mode),
 *   rules enforce that a document's internal owner ID fields must match the
 *   UID in its path upon creation, and that these IDs are immutable.
 *
 * @denormalization
 * This model uses path-based ownership, a form of structural denormalization.
 * The user's UID is part of the document path (e.g., `/users/{userId}`),
 * which makes the ownership context available for every rule without needing
 * to read another document. This avoids slow and costly `get()` calls in rules.
 * For example, a rule on `/users/{userId}/login_attempts/{attemptId}` can
 * authorize access simply by checking the `{userId}` wildcard from the path.
 *
 * @segregation
 * This model segregates each user's data into its own document tree. This is
 * the most secure pattern for private user data, as it makes it impossible
 * for queries or rules to accidentally cross user boundaries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * @description Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The UID to check against the authenticated user.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks for ownership on an existing document.
     * CRITICAL: Protects all update and delete operations from acting on
     * non-existent documents, which is a security best practice.
     * @param userId The UID of the document owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description On create, validates that the user document's internal `id`
     * field matches the document's path ID (the user's auth UID).
     * @param userId The UID from the document path.
     */
    function hasValidUserAccountDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * @description On update, ensures the `id` field within a user document
     * cannot be changed, preserving the link between the document and its owner.
     */
    function isUserAccountDataImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * @description On create, validates that a login attempt's internal
     * `userAccountId` field matches the parent user's document ID.
     * @param userId The UID from the document path.
     */
    function hasValidLoginAttemptDataOnCreate(userId) {
      return request.resource.data.userAccountId == userId;
    }

    /**
     * @description On update, ensures the `userAccountId` field within a
     * login attempt cannot be changed, preserving its relationship to the parent user.
     */
    function isLoginAttemptDataImmutable() {
      return request.resource.data.userAccountId == resource.data.userAccountId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user account documents. A user can create their own
     * account document and has full control over it thereafter. No one else
     * can read or write to it.
     * @path /users/{userId}
     * @allow A logged-in user (auth.uid='user123') can (create) their own document at /users/user123.
     * @deny A logged-in user (auth.uid='user123') cannot (get) another user's document at /users/user456.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // CRITICAL: Prevents listing all users in the application.
      allow create: if isOwner(userId) && hasValidUserAccountDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserAccountDataImmutable();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's login attempt history. Only the user
       * can create new login attempt records and view their own history.
       * @path /users/{userId}/login_attempts/{loginAttemptId}
       * @allow A user (auth.uid='user123') can (create) a new document in the /users/user123/login_attempts subcollection.
       * @deny An anonymous user cannot (list) documents in /users/user123/login_attempts.
       * @principle Enforces document ownership for a private subcollection.
       */
      match /login_attempts/{loginAttemptId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidLoginAttemptDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && isLoginAttemptDataImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}